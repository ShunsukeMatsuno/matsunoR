% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ode.R
\name{ode_extended}
\alias{ode_extended}
\title{Integrate an ODE with an arbitrary initial time}
\usage{
ode_extended(
  y,
  times,
  func,
  parms,
  init_time,
  method = c("lsoda", "lsode", "lsodes", "lsodar", "vode", "daspk", "euler", "rk4",
    "ode23", "ode45", "radau", "bdf", "bdf_d", "adams", "impAdams", "impAdams_d",
    "iteration"),
  ...
)
}
\arguments{
\item{y}{Numeric vector. The state of the system at \code{init_time}.}

\item{times}{Numeric vector. All time points at which you want the solution
returned.  Must cover \code{init_time} (i.e. \verb{min(times) <= init_time <= max(times)}).}

\item{func}{Function defining the ODE right-hand side.  Must have signature
\code{func(t, y, parms)} and return a \code{list} of derivatives.}

\item{parms}{Numeric or list.  Parameters passed to \code{func}.}

\item{init_time}{\strong{This is the only difference from \code{deSolve::ode}}.
Numeric scalar.  The time within \code{times} at which
the initial condition \code{y} applies.}

\item{method}{See \code{deSolve::ode}.}

\item{...}{Additional arguments passed on to \code{deSolve::ode}.}
}
\value{
A numeric matrix whose first column is \code{time} (in ascending order)
and whose remaining columns are the state variables.
}
\description{
A wrapper around \code{deSolve::ode} that lets you specify the initial condition
\code{y} at some interior time point \code{init_time} within your \code{times} grid.
The function splits the integration into a backward run (from \code{init_time} down
to \code{min(times)}) and a forward run (from \code{init_time} up to \code{max(times)}),
then stitches the two results into a single, ascending-time solution.
}
\examples{
library(deSolve)
library(dplyr)
library(ggplot2)
# simple ODE: dy/dt = -0.5 * y
f <- function(t, y, parms) list(-0.5 * y)
# define time grid and interior init time
times <- seq(0, 10, by = 0.1)
init_time <- 4
init_y_vec <- seq(0, 3, by = 0.5)

# solve for each initial y in init_y_vec, stitch results, and plot
df <- tibble(init_y = init_y_vec) |>
  mutate(
    res = purrr::map(
      init_y,
      ~ as_tibble(
        ode_extended(
          y         = c(y = .x),
          times     = times,
          func      = f,
          parms     = NULL,
          init_time = init_time
        )
      )
    )
  ) |>
  tidyr::unnest(res)

df |>
  ggplot(aes(x = time, y = y, color = factor(init_y))) +
  geom_line() +
  geom_vline(xintercept = init_time, lty = 2) +
  geom_hline(yintercept = init_y_vec, lty = 3) +
  labs(color = "init_y") +
  theme_minimal()

}
\seealso{
\code{\link[deSolve:ode]{deSolve::ode()}}
}
